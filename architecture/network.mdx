---
title: "Network Architecture"
description: "Explore how Loyal’s client and service agents interact across the decentralized capability graph."
---

## Core Components

<Columns cols={3}>
  <Card title="Client Agents" icon="user-secret">
    You operate personal clients that hold preferences, budgets, and routing policy for every request.
  </Card>
  <Card title="Service Agents" icon="cubes">
    Specialized models advertise capability vectors and execute inside trusted execution environments.
  </Card>
  <Card title="Capability Registry" icon="diagram-project">
    A decentralized index maps capability embeddings to the agents that can fulfill them.
  </Card>
</Columns>


```mermaid
%%{init: {
  "theme": "dark",
  "flowchart": { "rankSpacing": 90, "nodeSpacing": 70, "padding": 20, "htmlLabels": true },
  "themeVariables": { "fontSize": "20px" }
}}%%
flowchart TB

%% =======================
%% Sections
%% =======================

subgraph FE[Frontend]
  U[User + Wallet]
  F[Frontend dApp]
  PDA[(PDA: chat state and history)]
  ESC[(Deposit Escrow)]
  MBV[MagicBlock Validator]
end

subgraph SC[Solana Smart Contracts on MagicBlock TEE]
  APP[App Contract]
  ORC[Oracle Contract]
  POLICY[Privacy: read access = user and oracle]
end

subgraph BE[Backend / TEE]
  LLM[Private Compute GPU / LLM]
end

%% =======================
%% Frontend behaviors
%% =======================
U -->|Connect wallet| F
F -->|Load prior chats on connect| PDA
F -->|Verify TEE attestation| MBV
F -->|Pay per request| ESC

%% =======================
%% Request / execution path
%% =======================
F -->|Submit question| APP
APP -->|CPI: notify query in chat| ORC
ORC -->|Verify and authorize| MBV
ORC -->|Execute| LLM
LLM -->|Stream tokens / bytes| ORC
ORC -->|Stream to PDA| PDA

%% =======================
%% Streaming + settlement
%% =======================
PDA -->|Updates stream| F
F -->|Render partial responses| U
APP -->|Deduct per token| ESC

%% Notes
POLICY -. applies .-> APP
F -. monitors .-> PDA
```

## Request Lifecycle

<Steps>
<Step title="Discover">
  You embed your request, compare it against published capability vectors, and shortlist candidate agents using cosine similarity.
</Step>
<Step title="Attest">
  Each candidate returns a hardware attestation quote. You verify code hashes and hardware fingerprints before sharing encrypted payloads.
</Step>
<Step title="Chain">
  Primary agents can invoke downstream specialists via functional tokens, creating execution graphs without leaking raw context.
</Step>
</Steps>

## Execution Graph Topology

<AccordionGroup>
<Accordion title="Master Nodes">
  Master agents maintain user state in graph databases for sub-second retrieval, while delegating heavy computation to workers.
</Accordion>
<Accordion title="Worker Nodes">
  Workers focus on domain-specific inference, reuse shared base models with lightweight adapters, and publish health heartbeats for routing.
</Accordion>
<Accordion title="Market Dynamics">
  Pricing adjusts to demand. Agents with sustained usage cluster alongside complementary capabilities, reducing latency and payment hops.
</Accordion>
</AccordionGroup>

<Info>
You should assume the network will evolve continuously—publishers push new capability vectors, and your routing logic should tolerate churn.
</Info>
